	def _t_control_init(self):
        """
        Initializes the Time Control utility (enabling oversampling)
        """
        # calc main-cycle time
        self.config.p_t_ctrl.set_main_ctime(
                self.config.p_t_ctrl.os_dec * self.config.p_loop.ittime)
        
        # set sub-cycle time
        self.config.p_t_ctrl.set_sub_ctime(self.config.p_loop.ittime)
        
        # set number of current sub-cycle
        self.config.p_t_ctrl.set_loop_it(0)
        
        # set number of following sub-cycles
        self.config.p_t_ctrl.set_main_cnt(self.config.p_t_ctrl.os_dec - 1)
        
        # init list of matrices containing the cumulated wfs-images
        self.config.p_t_ctrl.init_wfs_images( len(self.config.p_wfss) )
        
        # fill list of matrices containing the cumulated wfs-images
        for k in range( len(self.config.p_wfss) ):
            
            # check if wfs is a Shack-Hartmann sensor
            if self.config.p_wfss[k].type.decode("utf-8") == "sh":
                
                # fill matrix
                self.config.p_t_ctrl.set_single_wfs_image( idx = k, 
                        content = np.zeros(self.wfs.get_bincube(k).shape, dtype = np.float32) )
            
            # check if wfs is a pyramid sensor
            elif self.config.p_wfss[k].type.decode("utf-8") == "pyrhr":
                
                # fill matrix 
                self.config.p_t_ctrl.set_single_wfs_image( idx = k, 
                        content = np.zeros(self.wfs.get_pyrimg(k).shape, dtype = np.float32) )
                
                # if there is a pyramid sensor, then bool_pyr is set to True
                self.config.p_t_ctrl.set_bool_pyr(True)
                
                # change number of modulation points
                if self.config.p_t_ctrl.os_dec > 1:
                    self.config.p_wfss[k].set_pyr_npts(
                            self.config.p_t_ctrl.os_dec * self.config.p_t_ctrl.pyr_dec)
            
            # anything else (this should not happen)
            else:
                raise TypeError("Oops, something strange happened. It seems" + 
                                "that one wfs is neither sh nor pyrhr.")
        
        # init list of matrices containing the mirror-cmds
        self.config.p_t_ctrl.init_ctrl_cmds( len(self.config.p_dms) )
        
        # fill list of matrices containing the mirror-cmds
        for k in range( len(self.config.p_dms) ):
            
            # fill matrix
            self.config.p_t_ctrl.set_single_ctrl_cmd( idx = k, 
                content = np.zeros((self.config.p_t_ctrl.os_dec, self.config.p_dms[k]._ntotact), 
                                   dtype = np.float32) )
        
        # calculate modulation points for pyramid wfs
        if self.config.p_t_ctrl.bool_pyr:
            
            # calc modulation points and their scales
            [cx, cy, scale] = t_ctrl.calc_pyr_mod(
                    p_t_ctrl = self.config.p_t_ctrl, 
                    p_wfss = self.config.p_wfss,
                    tel_diam = self.config.p_tel.diam)
            
            # set modulation points
            self.config.p_t_ctrl.set_mod_cx(cx)
            self.config.p_t_ctrl.set_mod_cy(cy)
            
            # set scale of modulation points
            self.config.p_t_ctrl.set_mod_scale(scale)

        
        # print status of time control
        print()
        print("*-------------------------------")
        print("TIME CONTROL")
        
        # if os_dec = 1 then there is no time oversampling
        if self.config.p_t_ctrl.os_dec == 1:
            print("status: disabled")
        
        # there is time oversampling
        else:
            print("status: enabled")
            print("Time decimation: " + str(self.config.p_t_ctrl.os_dec) )
            print("Main cycle: " + str(self.config.p_t_ctrl.main_ctime * 1000) + " ms" )
            print("Sub cycle: " + str(self.config.p_t_ctrl.sub_ctime * 1000) + " ms" )
                        
            # print status of wfs
            if self.config.p_t_ctrl.bool_pyr:
                print("Pyramid wfs: present")
                print("Pyramid decimation: " + str(self.config.p_t_ctrl.pyr_dec))
            else:
                print("Pyramid wfs: not present")
            
            # print warnings of initialization
            if len(self.config.p_t_ctrl.warnings) == 0:
                 print("Warnings: none")
            else:
                print("Warnings: ")
                for k in range( len(self.config.p_t_ctrl.warnings) ):
                    print("   " + self.config.p_t_ctrl.warnings[k])
        
        print("*-------------------------------")



    def _z_aberration_init(self):
        """
        Initializes the custom zernike aberrations (in pupil)
        """
        if self.config.p_z_ab.include_zab:
           
            # set pup_diam if wildcard is used
            if self.config.p_z_ab.pup_diam == -1.0:
                # pup_diam = diameter of telescope pupil
                self.config.p_z_ab.set_pup_diam(self.config.p_tel.diam)
            
            # if pup_diam is given in meter
            if self.config.p_z_ab.pup_diam > 0.0:
                # raise error if pup_diam >= diam_data
                if self.config.p_z_ab.pup_diam >= self.config.p_z_ab.diam_data:
                    raise ArithmeticError("The telescope diameter (pup_diam) must" +
                                          "be smaller than the data diameter (diam_data)") 
                
                # calculate diameter of data (in pixel)
                diam_data_pix = z_aber.calc_trunc(
                        spupil_size = self.config.p_geom.pupdiam,
                        tel_diam = self.config.p_z_ab.pup_diam,
                        diam = self.config.p_z_ab.diam_data)
                
                # calculate cube of untruncated Zernike polynomials (size of data)
                zcube_untrunc = z_aber.calc_zcube(
                        n_zpol = self.config.p_z_ab.num_zpol, 
                        grid_p = diam_data_pix )
                
                # aberration is LARGER than mpupil
                if diam_data_pix > self.config.p_geom._n:
                    # Calculate matrix-padding on one side (mpupil and spupil)
                    pix_diff_mp = np.int((diam_data_pix - self.config.p_geom._n) / 2)
                    pix_diff_sp = np.int((diam_data_pix - self.config.p_geom.pupdiam) / 2)
                    
                    # truncate cube of Zernike modes for spupil (zcube_spup)
                    self.config.p_z_ab.set_zcube_spup( 
                            zcube_untrunc[:, pix_diff_sp:-pix_diff_sp, pix_diff_sp:-pix_diff_sp] )
            
                    # truncate cube of Zernike modes for mpupil (zcube_mpup)
                    self.config.p_z_ab.set_zcube_mpup( 
                            zcube_untrunc[:, pix_diff_mp:-pix_diff_mp, pix_diff_mp:-pix_diff_mp] )
                
                # aberration is AS LARGE AS mpupil
                elif diam_data_pix == self.config.p_geom._n:
                    # Calculate matrix-padding on one side (mpupil and spupil)
                    pix_diff_sp = np.int((diam_data_pix - self.config.p_geom.pupdiam) / 2)
                    
                    # truncate cube of Zernike modes for spupil (zcube_spup)
                    self.config.p_z_ab.set_zcube_spup( 
                            zcube_untrunc[:, pix_diff_sp:-pix_diff_sp, pix_diff_sp:-pix_diff_sp] )
            
                    # cube of Zernike modes for mpupil (zcube_mpup)
                    self.config.p_z_ab.set_zcube_mpup( zcube_untrunc )
                
                # aberration is SMALLER than mpupil
                else:
                    raise ArithmeticError("The diameter of the Zernike aberration " + 
                                          "must be as large as the mpupil.")
                
            
            # setup if wildcard is used
            elif self.config.p_z_ab.pup_diam == -2.0:
                # calculate cube of untruncated Zernike polynomials (size of data)
                zcube_untrunc = z_aber.calc_zcube(
                        n_zpol = self.config.p_z_ab.num_zpol, 
                        grid_p = self.config.p_geom._n )
                
                # Calculate matrix-padding on one side (spupil)
                pix_diff_sp = np.int((self.config.p_geom._n - self.config.p_geom.pupdiam) / 2)
                
                # truncate cube of Zernike modes for spupil (zcube_spup)
                self.config.p_z_ab.set_zcube_spup( 
                        zcube_untrunc[:, pix_diff_sp:-pix_diff_sp, pix_diff_sp:-pix_diff_sp] )
        
                # cube of Zernike modes for mpupil (zcube_mpup)
                self.config.p_z_ab.set_zcube_mpup( zcube_untrunc )
            
            # error if self.config.p_z_ab.pup_diam is not > 0 or = -2
            else:
                raise TypeError("pup_diam must be a float >0. or =-1. or =-2.")
            
            # load timeseries of Zernike coefficients (coeff_series) from mat-file
            self.config.p_z_ab.set_coeff_series( z_aber.load_variable(
                    f_dir = self.config.p_z_ab.file_dir,
                    f_name = self.config.p_z_ab.file_name,
                    mat_ver = self.config.p_z_ab.mat_vers,
                    var_name = self.config.p_z_ab.var_name_coeff) )
            
            # load time stamps coefficients (time_series) from mat-file
            self.config.p_z_ab.set_time_series( z_aber.load_variable(
                    f_dir = self.config.p_z_ab.file_dir,
                    f_name = self.config.p_z_ab.file_name,
                    mat_ver = self.config.p_z_ab.mat_vers,
                    var_name = self.config.p_z_ab.var_name_time).ravel() )
            
            # calculate time steps of time_series (step)
            self.config.p_z_ab.set_step( z_aber.calc_step(
                    time = self.config.p_z_ab.time_series, 
                    it_time = self.config.p_loop.ittime,
                    tol = 1e-12) )
            
            # calculate decimation of iteration time to steps of time_series
            self.config.p_z_ab.set_dec( int( 
                    np.round(self.config.p_z_ab.step / self.config.p_loop.ittime) ) )
            print(self.config.p_z_ab.dec)
            
            # calculate and set phase-screen for spupil
            if (self.config.p_z_ab.include_path == 1) or (self.config.p_z_ab.include_path == 3):
                self.tel.set_phase_ab_M1( z_aber.calc_phase_screen(
                        cube = self.config.p_z_ab.zcube_spup,
                        coeff = self.config.p_z_ab.coeff_series[0,:],
                        n_zpol = self.config.p_z_ab.num_zpol) )
            
            # calculate and set phase-screen for mpupil
            if (self.config.p_z_ab.include_path == 2) or (self.config.p_z_ab.include_path == 3):
                self.tel.set_phase_ab_M1_m( z_aber.calc_phase_screen(
                        cube = self.config.p_z_ab.zcube_mpup,
                        coeff = self.config.p_z_ab.coeff_series[0,:],
                        n_zpol = self.config.p_z_ab.num_zpol) ) 
            
            # print status of aberrations
            print()
            print("*-------------------------------")
            print("CUSTOM ZERNIKE ABERRATIONS")
            print("status: enabled")
            print("source file: %s" % self.config.p_z_ab.file_dir + self.config.p_z_ab.file_name)
            print("number of modes: " + str(self.config.p_z_ab.num_zpol))
            
            if self.config.p_z_ab.include_path == 0:
                print("inclusion: not included")
            elif self.config.p_z_ab.include_path == 1:
                print("inclusion: science (target) path")
            elif self.config.p_z_ab.include_path == 2:
                print("inclusion: analytic (WFS) path")
            elif self.config.p_z_ab.include_path == 3:
                print("inclusion: science (target) and analytic (WFS) path")
            else:
                raise TypeError("Something strange happened. " + 
                                "include_path must be 0, 1, 2 or 3.")
            
            if self.config.p_z_ab.pup_diam > 0.0:
                print("telescope diameter: " + str(self.config.p_z_ab.pup_diam))
            elif self.config.p_z_ab.pup_diam == -2.0:
                print("telescope diameter: data fitted to simulation")
            else:
                raise TypeError("Oops, something strange happened. " + 
                                "pup_diam must be > 0.0 or -1.0 or -2.0.")
            print("*-------------------------------")
        
        # nothing to initialize
        else:
            print()
            print("*-------------------------------")
            print("CUSTOM ZERNIKE ABERRATIONS")
            print("status: disabled")
            print("*-------------------------------")